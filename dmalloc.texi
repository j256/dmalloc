\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename dmalloc.info
@settitle Dmalloc Tutorial
@c %**end of header

@c ================================================================
@c This file has the new style title page commands.
@c Also, it uses `@@include' files instead of `@@input' files.

@c Run using special version of `texinfo.tex'.

@c Also, run `makeinfo' rather than `texinfo-format-buffer'.
@c ================================================================

@c ================================================================
@c $Id: dmalloc.texi,v 1.61 1994/10/04 17:42:17 gray Exp $
@c ================================================================

@ifinfo
This file is an introduction to the Dmalloc library which handles general
memory heap management.

Copyright @copyright{} 1992 and 1993 by the Antaire Corporation.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled ``Copying'' are included exactly as in the original,
and provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled ``Copying'' may be included in a
translation approved by the author instead of in the original English.
@end ifinfo

@titlepage
@title Debug Malloc Library
@subtitle Version 3.0.1
@subtitle September 1994
@author Gray Watson <gray@@antaire.com>

@page
Copyright @copyright{} 1992 and 1993 by the Antaire Corporation.

Published by Gray Watson @samp{<gray@@antaire.com>}

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled ``Copying'' are included exactly as in the original,
and provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled ``Copying'' may be included in a
translation approved by the author instead of in the original English.
@end titlepage

@node Top, Copying, (dir), (dir)
@top Debug Malloc Library

@cindex intro
@cindex author

This file documents the general-usage and the inner-workings of the
memory allocation or @dfn{dmalloc} library it accompanies (see
@file{version.h} for the version number).

The library has been designed as a drop in replacement for the system's
malloc, realloc, calloc, free and other memory management routines while
providing powerful debugging facilities.  It is also reasonably portable
having been successfully run on the following operating systems: AIX,
BSDI, DG/UX, HPUX, Irix, MS-DOG, OSF, Solaris, SunOS, Ultrix, and
probably a couple others.

The library is available from ftp.antaire.com in the
@file{antaire/src/dmalloc} directory (URL
@samp{ftp://ftp.antaire.com/antaire/src/dmalloc/dmalloc.tar.gz}).  I can
be reached at 
@iftex
@*
@end iftex
@samp{gray@@antaire.com} with any questions, feedback, or general
comments.  Gray Watson, Antaire Corporation.

@menu
* Copying::                     Library copying conditions.
* Allocation Basics::           Basic description of terms and functions.
* Features::                    Description of the benefits of the library.
* Programming::                 How to program with the library.
* Running::                     How to run programs with the library.
* Source Code::                 Information on the source and general concerns.
* Plugs::                       A couple soapbox comments.
* Index of Concepts::           Index of concepts in the manual.
@ifinfo
* Detailed Node Listing::       Listing of all the nodes in the manual.
@end ifinfo
@end menu

@node Copying, Allocation Basics, Top, Top
@chapter Library Copying Conditions.

@cindex copying

Permission to use, copy, modify, and distribute this software for any
purpose and without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies, and
that the name of Antaire not be used in advertising or publicity
pertaining to distribution of the document or software without specific,
written prior permission.

The Antaire Corporation makes no representations about the suitability
of the software described herein for any purpose.  It is provided "as
is" without express or implied warranty.

@node Allocation Basics, Features, Copying, Top
@chapter Basic Description of Terms and Functions.

@cindex basics

This section provides a basic definition of terms used throughout the
manual as well as a brief overview of the basic malloc functions and
examples of their use.  It is quite unnecessary for you to read this
section if you are familiar with using the heap allocation functions.

@menu
* Basic Definitions::           For defining general terms and concepts.
* Malloc Functions::            Functionality supported by all malloc libs.
@end menu

@node Basic Definitions, Malloc Functions,  , Allocation Basics
@section Basic Definitions of Terms and Concepts.

@cindex static memory
@cindex stack memory
@cindex heap memory

Any program can be divided into 2 logical parts: text and data.  Text is
the actual program code in machine-readable format and data is the
information that the text operates on when it is executing.  The data,
in turn, can be divided into 3 logical parts according to where it is
stored: @dfn{static}, @dfn{stack}, and @dfn{heap}.

Static data is the information whose storage space is compiled into the
program.

@example
/* global variables are allocated as static data */
int numbers[10];

main()
@{
        @dots{}
@}
@end example

Stack data is data allocated at run-time to hold information used inside
of functions.  This data is managed by the system in the space called
stack space.

@example
void foo()
@{
        /* this local variable is allocated on the stack */
        float total;
        @dots{}
@}
@end example

Heap data is also allocated at run-time and provides a programmer with
dynamic memory capabilities.

@example
main()
@{
        char * string;
        @dots{}

        /* allocate a string of 10 bytes */
        string = (char *)malloc(10);
        @dots{}

        /* de-allocate the string now that I'm done with it */
        (void)free(string);
        @dots{}
@}
@end example

It is the heap data that is managed by this library.

Although the above is an example of how to use the malloc and free
commands, it is not a good example of why using the heap for run-time
storage is useful.

Consider this: You write a program that reads a file into memory,
processes it, and displays results.  You would like to handle files with
arbitrary size (from 10 bytes to 1.2 megabytes and more).  One problem,
however, is that the entire file must be in memory at one time to do the
calculations.  You don't want to have to allocate 1.2 megabytes when you
might only be reading in a 10 byte file because it is wasteful of system
resources.  Also, you are worried that your program might have to handle
files of more than 1.2 megabytes.

A solution: first checkout the file's size and then, using the
heap-allocation routines, get enough storage to read the entire file
into memory.  The program will only be using the system resources
necessary for the job and you will be guaranteed that your program can
handle any sized file.

@node Malloc Functions,  , Basic Definitions, Allocation Basics
@section Malloc functions Supported by all Malloc Libraries.

All malloc libraries support 4 basic memory allocation commands.  These
include @dfn{malloc}, @dfn{calloc}, @dfn{realloc}, and @dfn{free}.  For
more information about their capabilities, do a @code{man 3 malloc} to
read the system's manual pages.

@table @samp
@item malloc
@cindex malloc
Usage: @code{pnt = (type *)malloc(unsigned int size);}

The malloc routine is the basic memory allocation routine.  It allocates
an area of size bytes.  It will return a pointer to the space requested.

@item calloc
@cindex calloc
@cindex Allocation of zeros
Usage: @code{pnt = (type *)calloc(unsigned int number, unsigned int
size);}

The calloc routine allocates a certain number of items, each of size
bytes, and returns a pointer to the space.  It is appropriate to pass in
a @code{sizeof(type)} value as the size argument.

Also, calloc nulls the space that it returns, assuring that the memory
is all zeros.

@item realloc
@cindex realloc
Usage: @code{new_pnt = (type *)realloc(void * old_pnt, unsigned
int new_size);}

The realloc function expands or shrinks the memory allocation in old_pnt
to new_size number of bytes.  Realloc copies the information in old_pnt
into the new_pnt space up to new_size bytes or until it copies all of
the information from old_pnt.

@item free
@cindex free
Usage: @code{(void)free(void * pnt);}

The free routine releases an allocation returned by malloc, calloc, or
realloc back to the heap.  This allows other parts of the program to
re-use memory that is not needed anymore.  It also guarantees that the
process does not grow too big and swallow a large portion of the system
resources.

@end table

@emph{NOTE}: the returned address from the memory
allocation/reallocation functions should @emph{always} be cast to the
appropriate pointer type for the variable being assigned.

@emph{WARNING}: there is a quite common myth that all of the space that
is returned by malloc libraries has already been cleared.  @emph{Only}
the calloc routine will zero the memory space it returns.

@node Features, Programming, Allocation Basics, Top
@chapter Description of the Benefits of the Library.

@cindex features

@menu
* Overview::                    General debugging concepts.
* Environment Variable::        The variable name and its features.
* Debug Tokens::                Description of the debugging token flags.
* Argument Checking::           Special checking of function arguments.
@end menu

@node Overview, Environment Variable,  , Features
@section Overview of General Debugging Concepts.

@cindex debugging concepts

The features of this library are controlled by an environmental
variable.  It enables the memory debugging features at runtime to help
locate problems, chart memory leaks, provide basic bounds checking, log
statistics, etc.. @xref{Environment Variable}.

The debugging features that are available can be divided into a couple
basic classifications:

@table @samp
@item file and line number information
@cindex file/line numbers
@cindex cpp
One of the nice things about a good debugger is its ability to provide
the file and line number of an offending piece of code.  This library
attempts to give this functionality with the help of @dfn{cpp}, the C
preprocessor.  If the file @file{dmalloc.h} is included, the library can
provide file and line information of the caller of a dmalloc function
for the warning messages and errors it generates.  @xref{Allocation
Macros}.

@item return-address information
@cindex return-address
To debug calls to the library from external sources (i.e. those files
that did not include @file{dmalloc.h}), some facilities have been
provided to supply the callers address.  This address, with the help of
a debugger, can provide a lot of debugging information.  @xref{Return
Address}.

@item fence-post (i.e. bounds) checking
@cindex fence-post checking
@cindex bounds checking
@dfn{Fence-post} memory is the area immediately above or below memory
allocations.  I have found it all too easy to write code that accesses
above or below an allocation (especially when dealing with arrays or
strings).  The library can write special values in the areas around
every allocation so it will notice when these areas have been
overwritten.  @xref{Fence-Post Overruns}.

@emph{NOTE}: The library cannot notice when the program reads from these
areas, only when it writes values.  Also, fence-post checking will
increase the amount of memory the program allocates.

@item heap-constancy verification
@cindex constancy verification
The administration of the library is reasonably complex.  If any of the
heap-maintenance information is corrupted, the program will either crash
or give unpredictable results.

By enabling heap-consistency checking, the library will run through its
administrative structures to make sure all is in order.  This will mean
that problems will be caught faster and diagnosed better.

The drawback of this is, of course, that the library often takes quite a
long time to do this.  It is suitable to enable this only during
development and debugging sessions.

@emph{NOTE}: the heap checking routines cannot guarantee that the tests
will not cause a segmentation-fault if the heap administration
structures are properly (or improperly if you will) overwritten.  In
other words, they will verify that everything is okay but may not inform
the user of problems in a graceful manner.

@item logging statistics
@cindex logging statistics
@cindex statistics
@cindex memory leaks
One of the initial reasons why I personally wanted debug malloc
capabilities is to track my programs' memory usage -- specifically to
locate @dfn{memory leaks} which are places where allocated memory is
never getting freed.  @xref{Memory Leaks}.

The library has a number of logging capabilities that can track run-time
memory usage, administrative actions, final program statistics, as well
as un-freed memory pointers.  This information is also good at providing
more general debugging feedback.

@item examining unfreed memory
@cindex unfreed memory
Another common problem with programs is that they free a memory pointer
but then use go on to use it again by mistake.  This can lead to
mysterious crashes and unexplained problems.

To combat this, the library can write special values into a block of
memory after it has been freed.  This serves two purposes: it will make
sure that the program will get garbage data if it trying to access the
area again, and it will allow the library to verify the area later for
signs of overwriting.
@end table

If any of the above debugging features detect an error, the library will
try to recover.  If logging is enabled then an error will be logged with
as much information as possible.

The error messages that the library displays are designed to give the
most information for developers.  If the error message is not
understood, then it is most likely just trying to indicate that a part
of the heap has been corrupted.  The bug is most likely near the last
call made to the library so reviewing the code around this area is
recommended.

The library can be configured to quit immediately when an error is
detected and to dump a core file or memory-image.  This can be examined
with a debugger to determine the source of the problem.

Other debug malloc libraries also support the ability to dump core and
then continue running.  I decided not to support this once it was
determined that some versions of @code{fork} make calls to malloc which
would cause the library to go recursive.

@cindex system memory problems
@emph{NOTE}: do not be surprised if the library catches problems with
your system's library routines.  It took me hours to finally come to the
conclusion that the localtime call, included in SunOS release 4.1,
overwrites one of its fence-post markers.

@node Environment Variable, Debug Tokens, Overview, Features
@section Environment Variable - Its Name and Features.

@cindex environment variable
@cindex setenv
@cindex export

An @dfn{environment variable} is a variable that is part of the user's
working environment and are shared by all the programs.  The
@samp{DMALLOC_OPTIONS} variable is used by the dmalloc library to enable
or disable the memory debugging features, at runtime.  It can be set
either by hand or with the help of the dmalloc program.  @xref{Dmalloc
Program}.

To set it by hand, C shell (csh or tcsh) users need to invoke:

@example
setenv DMALLOC_OPTIONS value;
@end example

Bourne shell (sh, bash, ksh, or zsh) users should use:

@example
DMALLOC_OPTIONS=value;
export DMALLOC_OPTIONS;
@end example

The @samp{DMALLOC_OPTIONS} variable should be set to a comma separated
list of tokens with a corresponding value.  Each of the tokens is
described below:

@table @samp
@item debug
@cindex debug setting
This should be set to a value in hexadecimal which corresponds to the
functionality token values added together.  @xref{Debug Tokens}.  For
instance, if the user wanted to enable the logging of memory
transactions (value @samp{0x008}) and wanted to check fence-post memory
(value @samp{0x400}) then @samp{debug} should be set to @samp{0x408}
(@samp{0x008} + @samp{0x400}).

@emph{NOTE}: You don't have to worry about remembering all the hex
values of the tokens because the dmalloc program automates the setting
of this variable especially.

@emph{NOTE}: You can also specify the debug tokens directly, separated
by commas.  @xref{Debug Tokens}.  If @samp{debug} and the tokens are
both used, the token values will be added to the debug value.

@item log
@cindex logfile setting
@cindex logging information to disk
Set this to a filename so that if @samp{debug} has logging enabled, the
library can log transactions, administration information, and/or errors
to the file so memory problems and usage can be tracked.

To get different logfiles for different processes, you can assign
@samp{log} to a string with @code{%d} in it (for instance
@samp{logfile.%d}).  This will be replaced with the pid of the running
process (for instance @samp{logfile.2451}).

@emph{WARNING}: it is easy to core dump any program with dmalloc, if
you send in a format with arguments other than the one @code{%d}.

@item addr
@cindex address setting
@cindex address locating
When this is set to a hex address (taken from the dmalloc log-file for
instance) dmalloc will abort when it finds itself either allocating or
freeing that address.

The address can also have an @samp{:number} argument.  For instance, if
it was set it to @samp{0x3e45:10}, the library will kill itself the 10th
time it sees address @samp{0x3e45}.  By setting the number argument to
0, the program will never stop when it sees the address.  This is useful
for logging all activity on the address.

This makes it easier to track down specific addresses not being freed.

@emph{NOTE}: dmalloc will also log all activity on this address along
with a count.

@item inter
@cindex inter setting
By setting this to a number X, dmalloc will only check the heap every X
times.  This means a number of debugging features can be enabled while
still running the program within a finite amount of time.

I have found that a setting of @samp{100} works well with reasonably
memory intensive programs.  This of course means that the library will
not catch errors exactly when they happen but possibly 100 library calls
later.

@item start
@cindex start setting
Set this to a number X and dmalloc will begin checking the heap after X
times.  This means the intensive debugging can be started after a
certain point in a program.

@samp{start} also has the format file:line.  For instance, if it is set
to
@iftex
@*
@end iftex
@samp{dmalloc_t.c:126} dmalloc will start checking
the heap after it sees a dmalloc call from the @file{dmalloc_t.c} file,
line number 126.  If line number is 0 then dmalloc will start checking
the heap after it sees a call from anywhere in the @file{dmalloc_t.c}
file.

This allows the intensive debugging to be started after a certain
routine or file has been reached in the program.
@end table

Some examples are:

@example
# turn on transaction and stats logging and set 'malloc' as the log-file
setenv DMALLOC_OPTIONS log-trans,log-stats,log=malloc

# enable debug flags 0x1f as well as heap-checking and set the interval
# to be 100
setenv DMALLOC_OPTIONS debug=0x1f,check-heap,log=malloc

# enable 'malloc' as the log-file, watch for address '0x1234', and start
# checking when we see file.c line 123
setenv DMALLOC_OPTIONS log=malloc,addr=0x1234,start=file.c:123
@end example

@node Debug Tokens, Argument Checking, Environment Variable, Features
@section Debugging Tokens.

@cindex debug tokens

The below tokens and their corresponding descriptions are for the
setting of the @samp{debug} part of the @samp{DMALLOC_OPTIONS} variable.
@xref{Environment Variable}.  They should be specified in the user's
@file{.dmallocrc} file @xref{RC File}.

Each token, when specified, enables a specific debugging feature.  For
instance, if you have the log-stats token enabled, the library will log
general statistics to the logfile.

To get this information on the fly, use @samp{dmalloc -TV}.  This
will print out the Tokens in Very-verbose mode @xref{Dmalloc
Program}.

@table @samp
@item none
no debugging functionality

@item log-stats
log general statistics when dmalloc_shutdown or dmalloc_log_stats is
called

@item log-non-free
log non-freed memory pointers when dmalloc_shutdown or dmalloc_log_unfreed
is called

@item log-error
log heap error-messages

@item log-trans
log general memory transactions (quite verbose)

@item log-stamp
log a time stamp for all messages

@item log-admin
log administrative information (quite verbose)

@item log-blocks
log detailed block information when dmalloc_log_heap_map is called

@item log-unknown
like log-non-free but logs non-freed memory pointers that did not have
file/line information associated with them.

@item log-bad-space
log actual bytes in and around bad pointers

@item log-nonfree-space
log actual bytes in non-freed pointers

@item check-fence
check fence-post memory areas

@item check-heap
verify heap administrative structure

@item check-lists
examine internal heap linked-lists

@item check-free
check to see if free space has been overwritten.  @emph{NOTE}: this
enabled free-blank also.

@item check-funcs
check the arguments of some functions (mostly string operations) looking
for bad pointers

@item realloc-copy
always copy data to a new pointer when realloc

@item free-blank
write special bytes (decimal 197, octal 0305, hex 0xc5) into space when
it is freed

@item error-abort
abort the program (and dump core) on errors

@item alloc-blank
write special bytes (decimal 197, octal 0305, hex 0xc5) into space when
it is alloced

@item heap-check-map
log a heap-map to the logfile every time the heap is checked

@item print-error
log any errors and messages to the screen via standard-error

@item catch-null
abort the program immediately if the library fails to get more heap
space from sbrk
@cindex sbrk

@item never-reuse
have the heap never use space that has been used before and freed.
@emph{WARNING}: This should be used with caution since you may run out
of heap space.

@item allow-nonlinear
have the heap not complain when additional program functionality seems
to have made use of the system's heap-allocation routines directly.

@emph{WARNING}: This should be used with caution since it may hide
certain heap problems.

@emph{NOTE}: If you are using the pthreads package, you will probably
have to enable this since it seems to employ sbrk directly for some
reason.

@end table

@node Argument Checking,  , Debug Tokens, Features
@section Argument Checking of Certain Function Arguments.

@cindex argument checking
@cindex DMALLOC_FUNC_CHECK flag

One potential problem with the library and its multitude of checks and
diagnoses is that they only get performed when a dmalloc function is
called.  One solution this is to include @file{dmalloc.h} and compile
your source code with the @code{DMALLOC_FUNC_CHECK} flag defined and
enable the @code{check-funcs} token @xref{Debug Tokens}.

@example
gcc -DDMALLOC_FUNC_CHECK file.c
@end example

@emph{NOTE}: Once you have compiled your source with DMALLOC_FUNC_CHECK
enabled, you will have to recompile with it off to disconnect the
library @xref{Disabling the Library}.

When this is defined dmalloc will override a number of functions and will
insert a routine which knows how to check its own arguments and then
call the real function.  Dmalloc can check such functions as bcopy,
index, strcat, and strcasecmp (for the full list see the end of
@file{dmalloc.h}).

When you call strlen, for instance, dmalloc will make sure the string
argument's fence-post areas have not been overwritten, its file and line
number locations are good, etc.  With bcopy, dmalloc will make sure that
the destination string has enough space to store the number of bytes
specified.

For all of the arguments checked, if the pointer is not in the heap then
it is ignored since dmalloc does not know anything about it.

@emph{NOTE}: this is one of the newest parts of the library so problems
may still be lurking.

@node Programming, Running, Features, Top
@chapter How to Program With the Library.

@cindex usage

@menu
* Allocation Macros::           For providing file and line information.
* Return Address::              For providing caller information.
* Extensions::                  Additional non-standard routines.
* C++ and the Library::         Using the Library with C++.
* Disabling the Library::       How to compile/link without the library.
@end menu

@node Allocation Macros, Return Address,  , Programming
@section Allocation macros.

@cindex Allocation Macros
@cindex dmalloc.h file

By including @file{dmalloc.h} in your C files, your calls to calloc,
free, malloc, or realloc are replaced with calls to _calloc_leap,
_free_leap, _malloc_leap, and _realloc_leap.

@cindex leap macros

These @dfn{leap macros} use the c-preprocessor @code{__FILE__} and
@code{__LINE__} macros which get replaced at compilation time with the
current file and line-number of the source code in question.  The leap
routines take this information and pass it on to the library making it
able to produce verbose reports on memory not freed:

@example
not freed: 0x38410 ( 22 bytes) from 'dmalloc_t.c:92'
not freed: 0x38600 ( 10232 bytes) from 'dmalloc_t.c:104'
@end example

These lines from a log file shows that two allocations were not freed.
One at address 0x38410 of size 22 bytes in source file @file{dmalloc_t.c}
at line 92 and another at address 0x38600 of size 10232 bytes at line
104 of @file{dmalloc_t.c}.

Along with the above leap macros, @file{dmalloc.h} also contains the
following macros which I have been using for all our memory allocation
needs for some time now.  They take care of all the type-casting and
make the code look much cleaner (IMHO).

@table @code
@item ALLOC(type, count)
Usage: @code{long_pnt = ALLOC(long, 30);}.  This means allocate space
for 30 longs.

@item MALLOC(size)
Usage: @code{char_pnt = MALLOC(1000);}.  This is like ALLOC but for
characters only.  It means allocate space for 1000 characters.

@item CALLOC(type, count)
Usage: @code{info_pnt = CALLOC(struct info_st, 100);}.  This means
allocate space for 100 info_st structures and zero them all.

@emph{NOTE}: the arguments for the CALLOC macro are sort of reversed
from calloc(unsigned int count, unsigned int size).

@item REALLOC(pnt, type, count)
Usage: @code{long_pnt = REALLOC(old_pnt, long, 10);}.  This takes
old_pnt and and changes its size to accommodate 10 longs.

@item REMALLOC(pnt, size)
Usage: @code{char_pnt = REMALLOC(char_pnt, 100);}.  This is like REALLOC
but for characters only.  It takes char_pnt and changes its size to 100
characters.

@item FREE(pnt)
Usage: @code{FREE(pnt);}.  This frees memory pointers.

@item STRDUP(string)
Usage: @code{char_pnt = STRDUP("hello");}.  This macro duplicates the
functionality of the @samp{strdup} function.  string can be either a
static string like "hello" or a character pointer.  Non-gcc users should
use @code{STRDUP("hello", char_pnt);} where char_pnt is the variable
which will be assigned to the pointer to the copy of "hello".

@item BDUP(pnt, size)
Usage: @code{new_item_pnt = BDUP(&item, sizeof(item));}.  This allocates
space for size bytes, copies size bytes from pnt into the new allocation
and returns it.  It is like strdup but for non-strings.  Non-gcc users
should use @code{BDUP(&item, sizeof(item), new_item_pnt);} where
new_item_pnt is the variable which will be assigned the pointer to the
copy of item.
@end table

STRDUP, for those who are not familiar with the strdup(3) function,
takes a string, allocates enough information to store the string (along
with its null character), and then copies the string into the new space.
This macro does not actually call strdup but provides the same
functionality while giving file and line memory information to the
library.

BDUP is a function that I invented.  I use it to duplicate structures or
other elements that are not strings.  A pointer to an element and its
size are passed in and the macro returns an allocated copy of it.

@cindex gcc

gcc (GNUs c-compiler) has a neat feature in that it understands
return-values from macros.  I have included a gcc form of these 2 macros
(which makes them a lot more functional) as well as a non-gcc version.

@emph{NOTE}: I would like to strongly recommend the usage of gcc.  It is
a superior compiler and future releases of this library may even require
its use.

@node Return Address, Extensions, Allocation Macros, Programming
@section Making use of the caller's address information.

@cindex return-address

Even though the allocation macros can provide file/line information for
some of your modules, there are still modules which either you can't
include @file{dmalloc.h} or you just don't want to.  For the routines
which use dmalloc calls in these files, you can get return-address
information instead.  To accomplish this, you must be using this library
on one of the supported architecture/compilers.  @xref{Portability}.

The library attempts to use some assembly hacks to get the the
return-address or the address of the line that called the dmalloc
function.  If you have the @samp{log-ra} token enabled and you run your
program, you might see the following non-freed memory messages.

@example
not freed: 0x38410 ( 22 bytes) from 'ra=0xdd2c'
not freed: 0x38600 ( 10232 bytes) from 'ra=0x10234d'
not freed: 0x38220 ( 137 bytes) from 'ra=0x82cc'
@end example

With the help of a debugger, these return-addresses (or ra) can then be
identified.  I've provided a @file{ra_info.pl} perl script in the
@file{contrib/} directory with the dmalloc sources which seems to work
well with gdb.  You can also use the manual methods below for gdb.

@example
(gdb) x 0xdd2c
0xdddc <on_exit+4>:     0x7fffd8fd

(gdb) x 0x10234d
0x10234d <_findbuf+132>: 0x7fffceb7

(gdb) info line *(0x82cc)
Line 1092 of "argv.c" starts at pc 0x7540 and ends at 0x7550.
@end example

In the above example, gdb was used to find that the two non-freed memory
pointers were alloc'ed in on_exit(), _fund_buf(), and in file argv.c
line 1092 respectively.  The @samp{x address} (for examine) can always
be used on the return-addresses but the @samp{info line *(address)} will
only work if that file was compiled using the -g option and has not
been stripped.

@node Extensions, C++ and the Library, Return Address, Programming
@section Extensions: Non-Standard Dmalloc Routines.

@cindex extensions

The library has a number of variables and routines that are not a
standard part of most malloc libraries:

@table @code
@item char * dmalloc_logpath;
@cindex dmalloc_logpath variable
This variable can be used to set the dmalloc log filename.  The env
variable
@iftex
@*
@end iftex
DMALLOC_LOGFILE overrides this variable.

@item int dmalloc_errno;
@cindex dmalloc_errno variable
This variable stores the internal dmalloc library error number like errno
does for the system calls.  It can be passed to @code{dmalloc_strerror()}
(see below) to get a string version of the error.  It will have a value
of zero if the library has not detected any problems.

@item int dmalloc_address;
@cindex dmalloc_address variable
This variable hold the address to be specifically looked for when
allocating or freeing by the library.

@item int dmalloc_address_count;
@cindex dmalloc_address_count variable
This variable hold the argument to the @samp{addr} part of the
@samp{DMALLOC_OPTIONS} variable.  If it is set to a greater than 0 value
then after the library has seen the @samp{addr} address this many times,
it will call @code{dmalloc_error()}.

@item void dmalloc_shutdown(void);
@cindex dmalloc_shutdown function
This routine shuts the library down and logs the final statistics and
information especially the non-freed memory pointers.  The library has
code to support auto-shutdown if your system has @code{on_exit()} or
@code{atexit()} calls.  If you do not have these routines, then
@code{dmalloc_shutdown} should be called right before @code{exit()} or as
the last function in @code{main()}.

@example
main()
@{
        @dots{}
        dmalloc_shutdown();
        exit(0);
@}
@end example

@item void dmalloc_log_heap_map(void);
@cindex dmalloc_log_heap_map function
This routine will log to the logfile (if it is enabled) a graphical
representation of the current heap space.

@item void dmalloc_log_stats(void);
@cindex dmalloc_log_stats function
This routine dumps the current dmalloc statistics to the log file.

@item void dmalloc_log_unfreed(void);
@cindex dmalloc_log_unfreed function
This routine dumps the unfreed-memory information to the log file.  This
is also useful to dump the currently allocated points to the log file to
be diff'ed against another dump later on.

@item int dmalloc_verify(char * pnt);
@cindex dmalloc_verify function
Use this routines to verify individual memory pointers that are suspect
of memory problems.  To check the entire heap pass in a NULL or 0
pointer.  The routine returns DMALLOC_VERIFY_ERROR or
DMALLOC_VERIFY_NOERROR.

@emph{NOTE}: @samp{dmalloc_verify()} can only check the heap with the
functions that have been enabled.  For example, if fence-post checking
is not enabled in the @samp{DMALLOC_OPTIONS} variable,
@samp{dmalloc_verify()} cannot check the fence-post areas in the heap.

@item void dmalloc_debug(long debug);
@cindex dmalloc_debug function
With this routine, the value in the @samp{debug} part of the
@samp{DMALLOC_OPTIONS} variable can be overridden and the library
debugging features set explicitly.  For instance, if debugging should
never be enabled for a program, a call to @code{dmalloc_debug(0);} as
the first call in @code{main()} will disable all the memory debugging
from that point on.

One problem however is that some systems make calls to memory allocation
functions @emph{before} @code{main()} is reached therefore before
@code{dmalloc_debug()} can be called meaning some debugging information
may be generated regardless.

@item int dmalloc_debug_current(void);
@cindex dmalloc_debug_current function
This routine returns the current value in the @samp{debug} part of the
@samp{DMALLOC_OPTIONS} variable.  This allows you to save a copy of the
debug dmalloc settings to be changed and then restored later.

@item int dmalloc_examine(char * pnt, int * size, char ** file, int * line,
void ** ret_address);
@cindex dmalloc_examine function
This routine provides some very interesting functionality.  It returns
the size of a pnt's allocation as well as the file and line or the
return-address from where it was allocated.  It will return NOERROR or
ERROR depending on whether pnt is good or not.

@emph{NOTE}: This function is @emph{certainly} not provided by most if
not all other malloc libraries.

@item char * dmalloc_strerror(int errnum);
@cindex dmalloc_strerror function
@code{dmalloc_strerror} returns the string representation of the error
value in errnum (which probably should be dmalloc_errno).  This allows
the logging of more verbose memory error messages.

You can also display the string representation of an error value by a
call to the @file{dmalloc} program with a @samp{-e #} option
@xref{Dmalloc Program}.
@end table

@node C++ and the Library, Disabling the Library, Extensions, Programming
@section Using the Library with C++.

For those people using the C++ language, some special things need to be
done to get the library to work.  The problem exists with the fact that
the dynamic memory routines in C++ are @code{new()} and @code{delete()}
as opposed to @code{malloc()} and @code{free()}.

Place the following function definitions in a file and link this and the
dmalloc library in with the C++ program you want to debug.

@example
extern "C" @{
#include <stdlib.h>
@}

void *
operator new(size_t n)
@{
        return malloc(n);
@}

void
operator delete(void * cp)
@{
        free(cp);
@}
@end example

The above functions effectively redirect @code{new} to the more familiar
@code{malloc} and @code{delete} to the more familiar @code{free}.  They
also give the known error behavior, too.

@emph{NOTE}: I am not a C++ hacker so feedback in the form of other
hints and ideas for C++ users would be much appreciated.

@node Disabling the Library,  , C++ and the Library, Programming
@section Disabling the Library.

@cindex disabling the library

When you are finished with the development and debugging sessions, you
may want to disable the dmalloc library and put in its place either the
system's memory-allocation routines, gnu-malloc, or maybe your own.  I
have tried to make this a reasonably painless process.  The ease of the
extraction depends heavily on how many of the library's features your
made use of during your coding.

I am open to any reasonable suggestions as to how to improve this
process while maintaining the effectiveness of the debugging.

@itemize @bullet
@item
If you want to @emph{totally} disable the dmalloc library then you will
need to recompile all the C files that include @file{dmalloc.h} while
defining @code{DMALLOC_DISABLE}.  This will cause the dmalloc leap
macros to not be applied @xref{Allocation Macros}.

@example
gcc -O -g -DMALLOC_DISABLE main.c
@end example

@item
If you compiled any of your source modules with @code{DMALLOC_FUNC_CHECK}
defined then you must first recompile all those modules without the flag
enabled.

@item
Now you are ready to relink with a new library.  If you have not
compiled all your source with @code{DMALLOC_DISABLED} defined then you
need to include the @file{dmalloc_lp.o} file on the link line.  You need
to keep and eye out for multiple definition errors from your linker
since @file{dmalloc_lp.o} has hooks to various functions such as
@code{dmalloc_verify()}.

@example
gcc -O -g main.o dmalloc_lp.o -L/usr/local/lib -lgmalloc
@end example

If you have disabled dmalloc with the @code{DMALLOC_DISABLED} flag or
never included
@iftex
@*
@end iftex
@file{dmalloc.h} in any of your C files,
then you will not need to include the @file{dmalloc_lp.o} file on the
link line.

@example
gcc -O -g main.o -L/usr/local/lib -lgmalloc
@end example

If you get unresolved references like @code{_malloc_leap} or
@code{_dmalloc_bcopy} then something was not disabled as it should have
been.
@end itemize

@node Running, Source Code, Programming, Top
@chapter How to Run Programs With the Library.

@menu
* Dmalloc Program::             Env variable setting utility.
* RC File::                     Format of the run-time configuration file.
* Debugging with the Library::  How to debug problems with the library.
@end menu

@node Dmalloc Program, RC File,  , Running
@section Dmalloc Program: An Env Variable Setting Utility.

@cindex dmalloc program

The dmalloc program is designed to assist in the setting of the
environmental variable @samp{DMALLOC_OPTIONS}, especially the
@samp{debug} part.  @xref{Environment Variable}.  It is designed to
print the shell commands necessary to make the appropriate changes to
the environment.  Unfortunately, it cannot make the changes on its own
so the output from dmalloc should be sent through the @code{eval} shell
command which will do the commands.

With shells that have aliasing or macro capabilities: csh, bash, ksh,
tcsh, zsh, etc., setting up an alias to dmalloc to do the eval call
is recommended.  Csh/tcsh users (for example) should put the following
in their @file{.cshrc} file:

@example
alias dmalloc 'eval `\dmalloc -C \!*`'
@end example

Zsh users on the other hand should put the following in their
@file{.zshrc} file:

@example
dmalloc() @{ eval `command dmalloc -b $*` @}
@end example

This allows the user to execute @samp{dmalloc args}.

The most basic usage for the program is @samp{dmalloc [-bC] tag}.  The
-b or -C flags are for generating Bourne or C shell type commands
respectively.  dmalloc will try and use the @code{SHELL} environment
variable to determine whether bourne or c shell commands should be
generated but you may want to explicitly specify -b or -C.

The tag argument to dmalloc should match a line from the user's run-time
configuration file.  @xref{RC File}.  If no tag is specified and no
other option-commands used, dmalloc will display the current settings of
the environmental variable.

To find out the usage for the debug malloc program try @samp{dmalloc
--usage-all}.  This is one of the many features of the argv library
included with this package.  It is available from ftp.antaire.com in the
@file{antaire/src/argv} directory (URL
@samp{ftp://ftp.antaire.com/antaire/src/argv/argv.tar.gz}).  See
@file{argv.info} for more information.

Here is a detailed list of the flags that can passed to dmalloc:

@table @samp
@item -a address
Set the @samp{addr} part of the @samp{DMALLOC_OPTIONS} variable to
address (or alternatively address:number).

@item -b
Output Bourne shell type commands.

@item -C
Output C shell type commands.

@item -c
Clear/unset all of the settings not specified with other arguments.

@emph{NOTE}: clear will never unset the @samp{debug} setting.  Use
@samp{-d 0} or a tag to @samp{none} to achieve this.

@item -d bitmask
Set the @samp{debug} part of the @samp{DMALLOC_OPTIONS} env variable to
the bitmask value which should be in hex.  This is overridden (and
unnecessary) if a tag is specified.

@item -e errno
Print the dmalloc error string that corresponds to errno.

@item -f filename
Use this configuration file instead of the RC file
@file{$HOME/.dmallocrc}.

@item -i number
Set the @samp{inter} part of the @samp{DMALLOC_OPTIONS} env variable to
number.

@item -k
Keep the settings when using a tag.  This overrides -r.

@item -l filename
Set the @samp{log} part of the @samp{DMALLOC_OPTIONS} env variable to
filename.

@item -L
List all of the tags in the rc-file.  Useful with -v.

@item -m token(s)
Remove (minus) the debug capabilities of token(s) from the current debug
setting or from the selected tag (or -d value).  Multiple -m's can be
specified.

@item -n
Without changing the environment, output the commands resulting from the
supplied options.

@item -p token(s)
Add (plus) the debug capabilities of token(s) to the current debug
setting or to the selected tag (or -d value).  Multiple -p's can be
specified.

@item -r
Remove (unset) all settings when using a tag.  This is useful when you
are returning to a standard development tag and want the logfile,
address, and interval settings to be cleared automatically.  I put this
by default in my dmalloc alias.

@item -s number
Set the @samp{start} part of the @samp{DMALLOC_OPTIONS} env variable to
number (alternatively @samp{file:line}).

@item -T
List all of the debug-tokens.  Useful for getting a token to use with -p
or -m.

@item -v
Give verbose output.  Especially useful when dumping current settings or
listing all of the tags.
@end table

If no arguments are specified, dmalloc dumps out the current settings
that you have for the environmental variable.  For example:

@example
Debug-Flags  '0x40005c7' (runtime)
Address      0x1f008
Interval     100
Logpath      'malloc'
Start-File   not-set
@end example

With a -v option and no arguments, dmalloc dumps out the current
settings in a verbose manner.  For example:

@example
Debug-Flags  '0x40005c7' (runtime)
   log-stats, log-non-free, log-error, log-blocks, log-unknown, 
   log-bad-space, check-fence, catch-null
Address      0x1f008, count = 10
Interval     100
Logpath      'malloc'
Start-File   not-set
@end example

Here are some examples of dmalloc usage:

@example
# start tough debugging, check the heap every 1000 times,
# send the log information to file 'dmalloc'
dmalloc tough -i 1000 -l dmalloc

# find out what error code 20 is (from the logfile)
dmalloc -e 20

# after finding a corrupted address, cause the program to signal
# itself when it sees the address 0x34238 for the 6th time.
dmalloc -a 0x34238:6

# return to the normal 'runtime' settings and clear out all
# other settings
dmalloc -c runtime

# enable basic settings (1) plus (-p) the logging of
# transactions (log-trans) to file 'dmalloc'
dmalloc 1 -p log-trans -l dmalloc

# print out the current settings with Very-verbose output
dmalloc -V

# list the available debug malloc tokens with Very-verbose output
dmalloc -TV

# list the available tags from the rc file with verbose output
dmalloc -Lv
@end example

@node RC File, Debugging with the Library, Dmalloc Program, Running
@section Run-Time Configuration File.

@cindex rc file
@cindex runtime config file
@cindex dmallocrc file
@cindex .dmallocrc file
@cindex debug tags

By using a @dfn{RC File} (or run-time configuration file) you can alias
tags to combinations of debug tokens.  @xref{Debug Tokens}.  A sample
@file{dmallocrc} file has been provided but you are encouraged to roll
your own combinations.

The name of default rc-file is @file{$HOME/.dmallocrc}.  The @samp{$HOME}
environmental variable should be set by the system to point to your
home-directory.

The rc-file file should contain lines in the general form of:

@example
tag     token1, token2, ...
@end example

tag is to be matched with the tag argument passed to the dmalloc
program, while token1, token2, ... are debug capability tokens.
@xref{Dmalloc Program} and @ref{Debug Tokens}.

A line can be finished with a '\' meaning it continues onto the next
line.  Lines beginning with '#' are treated as comments and are ignored
along with empty lines.

Here is an example of a @file{.dmallocrc} file:

@example
#
# Dmalloc run-time configuration file for the debug malloc library
#

# no debugging
none    none

# basic debugging
debug1	log-stats, log-non-free, log-error, check-fence

# more logging and some heap checking
debug2	log-stats, log-non-free, log-error, log-trans, \
        check-fence, check-heap, check-lists, error-abort

# good utilities
debug3	log-stats, log-non-free, log-error, log-trans, \
        log-admin, check-fence, check-heap, check-lists, realloc-copy, \
        free-blank, error-abort

@dots{}
@end example

With the above file, when I say @code{eval `dmalloc debug1`}, for
example, I enable the logging of statistics, the logging of non-freed
memory, logging of errors, logging of bad pointers, and the checking of
fence-post memory areas.

When I say @code{eval `dmalloc none`}, all memory debugging features
are disabled.

@node Debugging with the Library,  , RC File, Running
@section Debugging program with the library.

Here are a number of possible scenarios for using the dmalloc library
to track down problems with your program.

In all cases, you should first have @samp{log} part of the
@samp{DMALLOC_OPTIONS} variable defined to a filename (I use
@file{dmalloc}).  You can use @samp{dmalloc -l dmalloc} to accomplish
this.  If you are interested in have the error messages be printed to
stderr instead, enable the @samp{print-error} token.

You should at least enable the following tokens: @samp{log-stats},
@samp{log-non-free}, @samp{log-error}, and @samp{log-bad-space}.  This
way, the library can log some helpful diagnostic information to the
log-file.

When running your program in a debugger (I use the @emph{excellent} GNU
debugger gdb), put a break-point in @code{dmalloc_error()} which is the
internal error routine for the library.  The program will then stop
there as soon as a memory problem is detected.

@menu
* General::                     Diagnosing general problems with a debugger.
* Memory Leaks::                Tracking down non-freed memory.
* Fence-Post Overruns::         Diagnosing fence-post overwritten memory.
@end menu

@node General, Memory Leaks,  , Debugging with the Library
@subsection Diagnosing general problems with a debugger.

@cindex diagnosing errors

Load your program (which should have the dmalloc library in it) with a
debugger and set a break-point at @code{dmalloc_error()}.  Run the
program.  If the program stops in the @code{dmalloc_error()} function,
this indicates that there was a problem.

There could be a problem with the arguments of the malloc call (asking
for negative number of bytes, trying to realloc a non-heap pointer,
etc.).  There also could be a problem with the system's allocations
(you've run out of memory, some other function in your program is using
@code{sbrk}, etc).  However, it is more likely that some code that has
been executed was naughty.

To get more information about the problem, first print dmalloc_errno to
get the heap's error code.  You can suspend your debugger and run
@samp{dmalloc -e value-returned-from-print} to get an english
translation of the error.  A number of the error messages are designed
to diagnose specific problems with the heap and may not be
user-friendly.

If the problem was due to the arguments or system allocations then the
source of the problem has been found.  However, if some code did
something wrong, you have more work to do.  The @code{check-heap} token
should be enabled and the @samp{inter} part of the
@samp{DMALLOC_OPTIONS} variable un-set or set to a low value so that the
library can find the problem as close as possible to its source.  The
code before the call to the library which stopped can then be examined
closely for irregularities.

@node Memory Leaks, Fence-Post Overruns, General, Debugging with the Library
@subsection Tracking down non-freed memory.

@cindex memory leaks

So you've run your program, examined the log-file and discovered (to
your horror) some un-freed memory.  I tend to be anal about memory leaks
since even the smallest and most insignificant leak can starve the
program given the right circumstances.

@example
not freed: 0x45008 (      12 bytes) from 'ra=0x1f8f4'
not freed: 0x45028 (      12 bytes) from 'unknown'
not freed: 0x45048 (      10 bytes) from 'argv.c:1077'
  known memory not freed: 1 pointer, 10 bytes
unknown memory not freed: 2 pointers, 24 bytes
@end example

Above you will see a sample of some non-freed memory messages from the
logfile.  Take the first line: the @samp{0x45008} is the pointer that
was not freed, the @samp{12 bytes} is the size of the unfreed block, the
@samp{ra=0x1f8f4} or return-address shows where the allocation
originated from.  To get more information from the return-address,
@xref{Return Address}.

The systems which cannot provide return-address information show
@samp{unknown} instead as in the 2nd line from the sample above.

The @samp{argv.c:@dots{}} information from the 3rd line comes from the
calls from C files which included @file{dmalloc.h}.  The file
overloads the malloc, calloc, free, and realloc calls and provides
specific file/line information to the dmalloc function calls.

At the bottom of the sample it totals the memory for you and breaks it
down to known memory (those calls which supplied the file/line
information) and unknown (the rest).

@node Fence-Post Overruns,  , Memory Leaks, Debugging with the Library
@subsection Diagnosing fence-post overwritten memory.

@cindex fence-post errors diagnosing

For a definition of fence-posts, @xref{Overview}.

If you have encountered a fence-post memory error, the logfile should be
able to tell you the offending address.

@example
overwrote lower fencepost: pointer '0x1c048' from 'dmalloc_t.c:387'
Dump of '0x1c048'-2: '\253WOW!\000\000\000\000\000\000\000\372\312\336'
ERROR: fence_read: failed UNDER picket-fence magic-number checking(10)
@end example

The above sample shows that the pointer @samp{0x1c048} has had its lower
fence-post area overwritten.  This means that the code wrote below the
bottom of the address or above the address right below this one.  In the
sample, the string that did it was @samp{WOW!}.

By enabling the @code{check-heap} and setting the @samp{inter} part of
the @samp{DMALLOC_OPTIONS} variable to a low number, you should be able
to locate approximately when this happened.

@node Source Code, Plugs, Running, Top
@chapter Information on the Source and General Concerns.

@cindex coding concerns

@menu
* Definitions::                 Some terms and other information.
* Compatibility::               General compatibility concerns.
* Portability::                 Issues important for porting the library.
@end menu

@node Definitions, Compatibility,  , Source Code
@section Definitions of Terms and Other Information.

@cindex definitions

Here are a couple definitions and other information for those interested
in "picking the brain" of the library.  The code is a little ugly here
and there and it conforms to the Gray-Watson handbook of coding
standards only.

@table @dfn
@item bblock
basic block containing 2 ^ BASIC_BLOCK bytes of info

@item bblock_adm
administration for a set of basic blocks

@item dblock
divided block containing some base 2 number of blocks smaller than a
basic block.

@item dblock_adm
administration for a set of divided blocks

@item chunk
some anonymous amount of memory
@end table

@node Compatibility, Portability, Definitions, Source Code
@section General Compatibility Concerns.

@cindex compatibility

@itemize @bullet
@item
Realloc() backwards compatibility with being able to realloc from the
last freed block is @emph{not} supported.  I would be interested to know
who is using this (cough, cough) feature and for what reason.

@item
Realloc() of a NULL pointer is supported in which case the library will
just make a call to malloc().  This can be disabled with the help of a
manual compilation option in the @file{conf.h} file.

@item
The library does @emph{not} provide memalign() nor valloc() support as
of yet, but may in future releases.  I would be interested to know who
is using these functions and for what reason.

@item
Some systems allow free(0) to not be an error for some reason (idiotic
IMHO).  Since 0 is not a valid address returned by the malloc call, I
don't see why free(0) should be allowed.  See @file{conf.h} for some
manual compilation options to handle this.

@item
Aside from possibly being slower than the system's memory allocation
functions, the library should be fully compatible with the standard
memory routines.  If this is @emph{not} the case, please bring this to
my attention.
@end itemize

@node Portability,  , Compatibility, Source Code
@section Portability Issues.

@cindex portability

General portability issues center around:

@itemize @bullet
@item
@cindex sbrk
sbrk or compatible function usages

@item
@cindex heap growing
Whether the systems' heap grows towards high or low memory.  The chunk.c
code is designed (loosely) around the fact that consecutive calls to
sbrk should give higher memory addresses.

I have not been able to test the library on a system whose heap grows
towards low memory.  If you are trying to run the library on such a
system I would be interested in talking with you.

@item
@cindex return-address
The locating of the caller's address from the dmalloc functions.
This is useful in locating problems from dmalloc functions called from C
files which did not include @file{dmalloc.h}: C library calls for
instance.

See @file{return.h} for the available architecture/compiler
combinations.  You may want to examine the assembly code from gcc
version 2+ being run on the following code.  It should give you a good
start on building a hack for your box.

@example
static char * x;

a()
@{
        x = __builtin_return_address(0);
@}

main()
@{
        a();
@}
@end example

@end itemize

@node Plugs, Index of Concepts, Source Code, Top
@chapter Soapbox Comments.

@cindex plugs

Since I have your attention I would like to talk for a second about a
couple of things that I feel strongly about.  If you would like any more
information about the below, please mail to the supplied addresses or
drop me a line with any questions.

@table @samp
@item The Electronic Frontier Foundation (EFF)
@cindex EFF
@cindex Electronic Frontier Foundation
The EFF is a organization committed to ensuring that the rules,
regulations, and laws being applied to emerging communications
technologies are in keeping with our society's highest traditions of the
free and open flow of ideas and information while protecting personal
privacy.  <eff@@eff.org>

@item Computer Professionals for Social Responsibility (CPSR)
@cindex CPSR
@cindex Computer Professionals for Social Responsibility
CPSR is a public-interest alliance of computer scientists and others
interested in the impact of computer technology on society.  We work to
influence decisions regarding the development and use of computers
because those decisions have far-reaching consequences and reflect basic
values and priorities.  <cpsr@@csli.stanford.edu>

@item Berkeley Software Design, Inc. (BSDI)
@cindex BSDI
@cindex BSD/386
@cindex Berkeley Software Design, Inc.
We at the Antaire Corporation are the proud and enthusiastic owners,
users, and distributors of the BSD/386 operating system.  For $1+k you
get a @emph{complete} BSD-flavor operating system with @emph{full
source} for 386 and 486 systems (binary licenses are available).  Along
with the obvious benefits of full source code come excellent customer
support/service and system features such as a MS-DOG runtime
environment, complete tcp/ip networking facilities including nfs, full
software development utilities, X, etc.  <bsdi-info@@bsdi.com>
@end table

@node Index of Concepts, Detailed Node Listing, Plugs, Top
@unnumbered Concept Index

@printindex cp
@contents

@ifinfo

@node Detailed Node Listing,  , Index of Concepts, Top
@unnumbered Detailed Node Listing

@menu
Top.

* Copying::                     Library copying conditions.
* Allocation Basics::           Basic description of terms and functions.
* Features::                    Description of the benefits of the library.
* Programming::                 How to program with the library.
* Running::                     How to run programs with the library.
* Source Code::                 Information on the source and general concerns.
* Plugs::                       A couple soapbox comments.
* Index of Concepts::           Index of concepts in the manual.
* Detailed Node Listing::       Listing of all the nodes in the manual.

Allocation Basics.

* Basic Definitions::           For defining general terms and concepts.
* Malloc Functions::            Functionality supported by all malloc libs.

Features.

* Overview::                    General debugging concepts.
* Environment Variable::        The variable names and their features.
* Debug Tokens::                Description of the debugging token flags.
* Argument Checking::           Special checking of function arguments.

Programming.

* Allocation Macros::           For providing file and line information.
* Return Address::              For providing caller information.
* Extensions::                  Additional non-standard routines.
* C++ and the Library::         
* Disabling the Library::       How to compile/link without the library.

Running.

* Dmalloc Program::             Env variable setting utility.
* RC File::                     Format of the run-time configuration file.
* Debugging with the Library::  How to debug problems with the library.

Debugging with the Library.

* General::                     Diagnosing general problems with a debugger.
* Memory Leaks::                Tracking down non-freed memory.
* Fence-Post Overruns::         Diagnosing fence-post overwritten memory.

Source Code.

* Definitions::                 Some terms and other information.
* Compatibility::               General compatibility concerns.
* Portability::                 Issues important for porting the library.
@end menu

@end ifinfo
@bye
