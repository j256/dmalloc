/*
 * manual configuration flags
 *
 * Copyright 1995 by Gray Watson
 *
 * This file is part of the dmalloc package.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * NON-COMMERCIAL purpose and without fee is hereby granted, provided
 * that the above copyright notice and this permission notice appear
 * in all copies, and that the name of Gray Watson not be used in
 * advertising or publicity pertaining to distribution of the document
 * or software without specific, written prior permission.
 *
 * Please see the PERMISSIONS file or contact the author for information
 * about commercial licenses.
 *
 * Gray Watson makes no representations about the suitability of the
 * software described herein for any purpose.  It is provided "as is"
 * without express or implied warranty.
 *
 * The author may be contacted at gray.watson@letters.com
 *
 * $Id: settings.dist,v 1.15 1997/12/08 02:45:24 gray Exp $
 */

/*
 * PROGRAMMING NOTE: this file cannot be included before conf.h, so
 * you might as well only include conf.h and never this file.
 */

#ifndef __SETTINGS_H__
#define __SETTINGS_H__

/*
 * should we include the RCS ids in the .c files and the installed
 * library?
 */
#define INCLUDE_RCS_IDS 1

/*
 * Should we allow zero length allocations?  This will generate the
 * smallest possible allocation.
 *
 * FYI: if fence post checking is requested, the top and bottom of the
 * fence post information will be touching.
 */
#define ALLOW_ALLOC_ZERO_SIZE 0

/*
 * Should we allow realloc of a NULL pointer?  If set to one, this
 * will call malloc when 0L is realloced.  This is useful when you are
 * extending an array in a loop and do not want to allocate it
 * specially the first time.
 */
#define ALLOW_REALLOC_NULL 1

/*
 * Should we allow the free of a NULL pointer and if it happens,
 * should a message be generated to that effect?  I don't see how this
 * would be useful but some systems can, and I guess require this --
 * especially X11 spaghetti code.  I would recommend at least using
 * the message to point out the offenders because I would guess that
 * this is not a portable feature of most malloc libraries.
 *
 * You can also enable the 'allow-zero' token which will not cause an
 * error when the user asks for 0 bytes and will not barf when it sees
 * a free(0L).
 */
#define ALLOW_FREE_NULL 0
#define ALLOW_FREE_NULL_MESSAGE 1

/*
 * Should we use the ra-address macros in return.h.  These are system
 * specific macros designed to return the return-address for logging
 * callers (i.e. possible offenders) of malloc routines.  You should
 * only want to disable them if you are storing code which makes calls
 * to the dmalloc functions *from* the heap.  This is unlikely but
 * will confuse the library.  Please mail me if you have any questions
 * or if you indeed have this problem.
 */
#define USE_RET_ADDRESS 1

/*
 * The largest allowable allocations in bits.  This is only for
 * verification purposes.  Any allocation larger than this (in bits)
 * will generate a ERROR_TOO_BIG error (#15).  the default (24)
 * indicates that an allocation of more than 16mb (2^24) will generate
 * an error.
 */
#define LARGEST_BLOCK 24

/*
 * Although I don't know why you would want to tune this since this is
 * pretty dependent on my general heap mechanisms, here are some
 * options to use general first, best, and worst fit algorithms.  If
 * you don't know what these are, then DON'T TOUCH.
 *
 * NOTES: they may go away in the future and/or be replaced by
 * debug-tokens.  I've tested all three and have not noticed any large
 * differences.  Also, they only apply for allocations > basic-block
 * (page) size.
 */
#define FIRST_FIT 1
#define BEST_FIT 0
#define WORST_FIT 0

/*
 * Automatically call dmalloc_shutdown if on_exit or atexit is
 * available.  See conf.h for whether configure found on_exit or
 * atexit calls.  If neither is available, take a look at atexit.c in
 * the contrib directory which may provide this useful functionality
 * for your system.
 */
#define AUTO_SHUTDOWN 1

/*
 * The ABORT_OKAY is auto-configured but may have to be adjusted by
 * forcing the USE_ABORT to be 1 or 0.  On some OS's, abort calls
 * fclose() which may want to free memory making the library go
 * recursive.  See ABORT_OKAY in the conf.h file for more information.
 *
 * If you need to override it or if ABORT_OKAY is 0, set KILL_PROCESS to
 * the proper way to stop the program.  Killing the current process
 * (id 0) with SIGABRT works on a number of Unix systems.  You may
 * have to define some include file to get the value for the signal
 * that is used.
 */
#if ABORT_OKAY
#define USE_ABORT		1
#else
#define USE_ABORT		0
#endif
#if SIGNAL_OKAY
#define KILL_INCLUDE		<signal.h>
#define KILL_PROCESS		(void)kill(0,SIGABRT)
#endif

/*
 * Define the signals that are to be caught by the catch-signals
 * token.  When caught, these signals will cause an automatic shutdown
 * of the library so that the unfreed memory and other statistics will
 * be displayed.
 */
#if SIGNAL_OKAY
#define SIGNAL1		SIGHUP
#define SIGNAL2		SIGINT
#define SIGNAL3		SIGTERM
#undef SIGNAL4
#undef SIGNAL5
#undef SIGNAL6
#endif

/*
 * Number of bytes to write at the top of allocations (if fence-post
 * checking is enabled).  A larger number means more memory space used
 * up but better protection against fence overruns.  See the manual
 * for more information.
 */
#define FENCE_TOP 4

/*
 * Number of bytes to write at the bottom of allocations. See the
 * FENCE_TOP setting above or the manual for more information.
 *
 * WARNING: this should changed with caution and should only be
 * increased.  If you need to change it, use (ALLOCATION_ALIGNMENT *
 * X) or some such.  For more information see ALLOCATION_ALIGNMENT in
 * conf.h.
 */
#define FENCE_BOTTOM		ALLOCATION_ALIGNMENT

/*
 * Write the iteration count at the start of every log entry.  This is
 * handy when you are using the DMALLOC_START variable and want to
 * begin the tough debugging at a certain point.
 */
#define LOG_ITERATION_COUNT 1

/*
 * Store the number of times a pointer is "seen" being allocated or
 * freed -- it shows up as a s# (for seen) in the logfile.  This is
 * useful for tracking of unfreed memory.  See the docs for more
 * information.
 * NOTE: This creates a certain amount of memory overhead.
 */
#define STORE_SEEN_COUNT 1

/*
 * Store the interation count or when a pointer is allocated -- it
 * shows up as a i# (for iteration) in the logfile.  This is to give
 * you some idea when during program execution, a pointer was
 * allocated but not freed.
 * NOTE: This creates a certain amount of memory overhead.
 */
#define STORE_ITERATION_COUNT 0

/*
 * Store the time (in seconds) or timeval (in seconds and
 * microseconds) when a pointer is allocated -- it shows up as a w#
 * (for when) in the logfile.  This is to give you some idea when a
 * pointer was allocated but not freed.  The library will log the
 * starting and the ending time if either of these flags is set.
 * TIMEVAL_INCLUDE is the include file to define struct timeval and
 * GET_TIMEVAL does the actual reading of the current time of day.
 *
 * WARNING: only TIME _or_ TIMEVAL can be defined at one time.
 * NOTE: This creates a certain amount of memory overhead.
 */
#define STORE_TIME 0
#define STORE_TIMEVAL 0
#define TIMEVAL_INCLUDE		<sys/time.h>
#define GET_TIMEVAL(t)		(void)gettimeofday(&(t), NULL)

/*
 * In OSF (anyone else?) you can setup __fini_* functions in each
 * module which will be called automagically at shutdown of the
 * program.  This means that dmalloc can shut itself down and log
 * statistics when the program closes.  Pretty cool.
 */
#define FINI_DMALLOC 0

/* If you enable this, you probably want the AUTO_SHUTDOWN flag turned off */
#if FINI_DMALLOC
#undef AUTO_SHUTDOWN
#define AUTO_SHUTDOWN 0
#endif

/****************************** thread settings ******************************/

/*
 * the following definition allows use of the library in threaded
 * programs.  The most common package is MIT's pthreads so this is the
 * default.  Please send me mail if these definitions are configurable
 * enough to work with your thread package.
 */
#define LOCK_THREADS 0
#if LOCK_THREADS

#define THREAD_INCLUDE			<pthread.h>

/* define a global variable we use as a lock counter */
#define THREAD_LOCK_GLOBAL	static pthread_mutex_t dmalloc_mutex;
#define THREAD_LOCK_INIT	pthread_mutex_init(&dmalloc_mutex, \
						   THREAD_LOCK_INIT_VAL);

/*
 * The problem is that the pthreads library uses malloc itself.  If we
 * attempt to call the global lock while inside of the pthreads
 * initialization code, the pthread library may core dump.  So we have
 * the dmalloc library not do the lock the first X times with the
 * lock-on dmalloc program env setting.  This is a HACK, however
 * necessary.
 *
 * You will have to play with the lock-on value.  Too many will cause two
 * threads to march into the dmalloc code generating a ERROR_IN_TWICE
 * -- the library is not thread safe.  Too few and you will get a core
 * dump in the pthreads init code.  Weeee!
 *
 * The pthreads library does not like to go recursive (I mean who does).
 * There are two places where this might happen.  One is for dmalloc
 * to try an mutex-lock when pthreads is starting up in a shaky state.
 * We hopefully solve this with the lock-on setting above.  The other
 * is when we go to initialize our mutex-lock.  Chances are that we
 * may cause a recursive call with this.  Below you will see that the
 * LOCK_INIT is called when the lock-on setting gets down to 2 -- not
 * 0.  0 is when the lock will be used so if we init then, the
 * recursive call into dmalloc will try to use a non-initialized lock
 * causing a seg-fault -- at least in OSF.  Sigh.
 */

/* when we should initialize our mutex variable */
#define INIT_LOCK_ON		2

#define THREAD_LOCK		do { \
				  if (thread_lock_on <= 0) \
				    pthread_mutex_lock(&dmalloc_mutex); \
				} while (0)
#define THREAD_UNLOCK		do { \
				  if (thread_lock_on > 0) { \
				    thread_lock_on--; \
				    if (thread_lock_on == INIT_LOCK_ON) { \
				      /* we init here to avoid recursion */ \
				      THREAD_LOCK_INIT; \
				    } \
				  } \
				  else \
				    pthread_mutex_unlock(&dmalloc_mutex); \
				} while (0)

/*
 * For those threaded programs, this logs the thread ID that allocated
 * the pointer -- it shows up as a t... (for thread-id) in the
 * logfile.  The ... is determined by the THREAD_ID_TO_STRING macro
 * below.  THREAD_TYPE defines the type of id storage field.
 * THREAD_GET_ID returns the current thread id.  It is assumed that
 * the THREAD_TYPE and THREAD_GET_ID macros are defined in the above
 * THREAD_INCLUDE file.
 *
 * NOTE: You may have to change the THREAD_GET_ID macro which is supposed
 * to return the thread-id integer to be stored in the pointer
 * structures.
 */
#define STORE_THREAD_ID 0
#define THREAD_TYPE			pthread_t
#define THREAD_GET_ID			pthread_self()
#define THREAD_ID_TO_STRING(b, t)	(void)sprintf((b), "%#lx", (long)(t))

#else /* LOCK_THREADS */

#define THREAD_LOCK
#define THREAD_UNLOCK

#endif /* ! LOCK_THREADS */

#endif /* ! __SETTINGS_H__ */
